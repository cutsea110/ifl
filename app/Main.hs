module Main where

import Data.Maybe (fromMaybe)
import System.Console.GetOpt
import System.Environment (getArgs)
import System.IO (getContents, hPutStr, hPutStrLn, stdout, stderr)

import qualified Template.Mark1 as Mark1 (parse, compile, eval, showResults)
import qualified Template.Mark2 as Mark2 (parse, compile, eval, showResults)
import qualified Template.Mark3 as Mark3 (parse, compile, eval, showResults)
import qualified Template.Mark4 as Mark4 (parse, compile, eval, showResults)


class Compiler c where
  executer :: c -> String -> IO ()

data Mk1 = Mk1
instance Compiler Mk1 where
  executer _ = putStrLn . Mark1.showResults . Mark1.eval . Mark1.compile . Mark1.parse
data Mk2 = Mk2
instance Compiler Mk2 where
  executer _ = putStrLn . Mark2.showResults . Mark2.eval . Mark2.compile . Mark2.parse
data Mk3 = Mk3
instance Compiler Mk3 where
  executer _ = putStrLn . Mark3.showResults . Mark3.eval . Mark3.compile . Mark3.parse
data Mk4 = Mk4
instance Compiler Mk4 where
  executer _ = putStrLn . Mark4.showResults . Mark4.eval . Mark4.compile . Mark4.parse


data Engine = Mark1  -- Mk1
            | Mark2  -- Mk2
            | Mark3  -- Mk3
            | Mark4  -- Mk4
            deriving Show

data Options = Options
  { optVerbose     :: Bool -- TODO
  , optShowVersion :: Bool
  , optEngine      :: Engine
  }

defaultOptions :: Options
defaultOptions = Options
  { optVerbose     = True  -- TODO
  , optShowVersion = False
  , optEngine      = Mark4
  }

options :: [OptDescr (Options -> Options)]
options = [ Option ['v']      ["verbose"] (NoArg (\opts -> opts {optVerbose = True}))
            "chatty output on stderr"
          , Option ['V', '?'] ["version"] (NoArg (\opts -> opts {optShowVersion = True}))
            "show version"
          , Option ['e']      ["engine"]  (ReqArg (\e opts -> opts {optEngine = decideEngine e}) "Engine")
            "compiler engine name [mark1|mark2|mark3|mark4]"
          ]
  where decideEngine :: String -> Engine
        decideEngine "mark1" = Mark1
        decideEngine "mark2" = Mark2
        decideEngine "mark3" = Mark3
        decideEngine "mark4" = Mark4
        decideEngine e       = error $ "Unknown engine: " ++ e

compilerOpts :: [String] -> IO (Options, [String])
compilerOpts argv =
  case getOpt Permute options argv of
    (o, n, []  ) -> return (foldl (flip id) defaultOptions o, n)
    (_, _, errs) -> ioError (userError (concat errs ++ usageInfo header options))
  where header = "Usage: cabal v2-run ifl -- [OPTION...] <program-file>"

run :: Options -> [String] -> IO ()
run opts (file:_) = do
  hPutStrLn stderr $ "Program Source: " ++ file
  exec =<< readFile file
  where exec = case optEngine opts of
          Mark1 -> executer Mk1
          Mark2 -> executer Mk2
          Mark3 -> executer Mk3
          Mark4 -> executer Mk4

printHelp :: IO ()
printHelp = do
  -- This banner generated by using 'figlet -f slant IFL'
  hPutStr stderr $ unlines [ "    ____________"
                           , "   /  _/ ____/ /"
                           , "   / // /_  / /"
                           , " _/ // __/ / /___"
                           , "/___/_/   /_____/ Implimenting Functional Languages"
                           , ""
                           , "> cabal v2-run ifl -- [OPTION...] <program-file>"
                           ]

main :: IO ()
main = do
  args <- getArgs
  (opts, rest) <- compilerOpts args
  if null rest then printHelp
    else run opts rest
