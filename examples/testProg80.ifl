mapMaybe f x = case x of
  <0>   -> Nothing;
  <1> y -> Just (f y);

Zero = Pack{0,0};
Succ n = Pack{1,1} n;

foldn c f n = case n of
  <0>   -> c;
  <1> m -> f (foldn c f m);

unfoldn psi x = case (psi x) of
  <0> -> Zero;
  <1> y -> Succ (unfoldn psi y);

out n = case n of
  <0>   -> Nothing;
  <1> m -> Just m;

NELUnit x = Pack{1,1} x;
NELCons x y = Pack{2,2} x y;

outNEL nel = case nel of
  <1> x -> Left x;
  <2> x xs -> Right (Pair x xs);

foldrNEL c f nel = case nel of
  <1> x -> c x;
  <2> x y -> f x (foldrNEL c f y);

unfoldrNEL psi x = case psi x of
  <1> a -> NELUnit a;
  <2> p -> case p of
    <2> a b -> NELCons a (unfoldrNEL psi b);

extract x = case x of
  <1> x   -> x;
  <2> x y -> x;
subtract = compose (either (K Nothing) (compose Just snd)) outNEL;

F a b c = a (b c) c;
G a b c d = F a b (c d);

histo phi = letrec
              u = G (S (compose maybe NELUnit) NELCons) phi (compose (mapMaybe u) out)
            in compose extract u;
dyna f g = compose (histo f) (unfoldn g);

phi x = case x of
  <0>   -> 0;
  <1> x -> extract x + maybe 1 extract (subtract x);
psi n = if (n == 0) Nothing (Just (n-1));

fib n = dyna phi psi n;

main = fib 20
